# 동적 계획법 (Dynamic Programming, DP)

동적 계획법(DP)은 복잡한 문제를 작은 하위 문제로 나누어 해결하고, 그 결과를 저장하여 같은 계산을 반복하지 않도록 하는 알고리즘 설계 기법입니다. DP는 주로 최적화 문제에서 사용되며, 특정 조건을 만족하는 문제에 적합합니다.

## DP를 사용하기 위한 조건

DP를 사용할 수 있는 문제는 다음 두 가지 조건을 만족해야 합니다:

1. **최적 부분 구조 (Optimal Substructure)**  
   큰 문제의 최적 해결 방법이 작은 문제들의 최적 해결 방법을 통해 구해질 수 있는 구조입니다. 예를 들어, 피보나치 수열은 다음과 같은 관계식을 가집니다:
    - `F(n) = F(n-1) + F(n-2)`

2. **중복되는 부분 문제 (Overlapping Subproblems)**  
   동일한 하위 문제가 여러 번 반복해서 계산되는 구조입니다. 피보나치 수열의 예에서는 `F(n-1)`과 `F(n-2)`를 여러 번 계산하게 됩니다.

![sample1.png](https://github.com/woohyo/algorithm/raw/main/image/dp.png)


## DP의 두 가지 접근 방식
DP에는 상향식 (Bottom-Up) 과 하향식 (Top-Down) 방식이 있습니다.

| 접근 방식       | 설명                                                                                 | 구현 방식       | 장점                                           | 단점                                     |
|----------------|------------------------------------------------------------------------------------|----------------|------------------------------------------------|------------------------------------------|
| **Top-Down**   | 큰 문제를 해결하기 위해 작은 문제를 재귀적으로 호출하며, 메모이제이션을 통해 중복 계산을 방지 | 재귀 + 메모이제이션 | 코드가 직관적이며 문제를 나누는 방식으로 접근이 용이 | 재귀 호출로 인해 스택 오버플로우가 발생할 수 있음 |
| **Bottom-Up**  | 작은 문제부터 해결하여 DP 테이블을 채워가며 큰 문제를 해결                             | 반복문         | 메모리 및 시간 효율성이 높음                    | 초기 테이블 설정과 반복문의 논리가 필요함         |

<blockquote> 
메모이제이션(Memoization)은 이미 계산한 결과를 저장하여 동일한 계산을 반복하지 않도록 하는 방법입니다.
<br>
메모이제이션을 통해 계산 시간을 줄이고, 중복 계산을 방지할 수 있습니다. 주로 Top-Down 방식의 DP에서 활용됩니다.
</blockquote>


### 1. 상향식 (Bottom-Up)
작은 문제부터 해결해 나가며 그 결과를 테이블에 저장하여 큰 문제를 해결하는 방식입니다. 일반적으로 **반복문**을 사용하여 구현합니다.

예) 피보나치 수열

```java
int fibonacci(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

### 2. 하향식 (Top-Down)
큰 문제를 해결하기 위해 작은 문제를 재귀적으로 호출하며, 이미 계산된 결과는 메모이제이션 (Memoization) 을 통해 저장하여 재사용합니다.
일반적으로 재귀와 메모이제이션을 함께 사용하여 구현합니다.

```java
int[] memo = new int[n + 1];
int fibonacci(int n) {
    if (n <= 1) return n;
    if (memo[n] != 0) return memo[n];
    return memo[n] = fibonacci(n - 1) + fibonacci(n - 2);
}

```